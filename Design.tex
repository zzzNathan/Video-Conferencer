\pagestyle{fancy}
\rhead{\bfseries OCR A-Level Computer Science}
\chead{\mdseries \thepage}
\lhead{\bfseries Jonathan Kasongo \mdseries â€” 2025/26}
\lfoot{\sffamily Candidate number: N/A}
\rfoot{\sffamily Centre number: N/A}

\usetikzlibrary{positioning}
\usetikzlibrary{calc}

\chapter{Design}

\section{Breaking the problem down}
\label{sec:breakdown}

\textit
{
We now provide a simple visual decomposition of the problem at 
hand. We let DB denote our database for typographical reasons.
}

\begin{figure}[h]
\label{fig:decomp}
\centering

\begin{tikzpicture}[every node/.style={scale=0.54}]

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, fill=lightestgray]
    (home) {\large Home page};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of home ]
    (login) {\large Login page};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below right=of home]
    (docs) {\large Documentation};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below left=of home]
    (help) {\large Help page};

  \node[draw, diamond, aspect=2, below=of login ]
    (new) {\large First time user?};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below left=of new ]
    (acc) {\large Create account};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of acc ]
    (add) {\large Add account to \textit{DB}};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below right=of new ]
    (back) {\large Log back in};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of back ]
    (main) {\large Main page};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below right=of main ]
    (join) {\large Join call page};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of join ]
    (code) {\large Enter passcode};

  \node[draw, diamond, aspect=2, minimum width=4cm, minimum height=1cm, below=of code ]
    (valid) {\large Is code valid?};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below left=of valid ]
    (codegood) {\large Connect to call};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below right=of valid ]
    (codebad) {\large Raise error};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of main ]
    (create) {\large Create call page};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of create ]
    (invite) {\large Invite others};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below left=of main ]
    (settings) {\large Settings page};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below left=of settings ]
    (video) {\large Video settings};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of settings ]
    (access) {\large Accessibility settings};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, left=of video ]
    (audio) {\large Audio settings};

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm, below=of video ]
   (save) {\large Save settings to \textit{DB}};

  \coordinate[right=2cm of code.east] (here);

  \coordinate[below=1.26cm of access.south] (a);

  \coordinate[below=1.26cm of audio.south] (b);

  \draw[black, -{Latex[length=2.5mm]}] 
    (home) -- (login);

  \draw[black, -{Latex[length=2.5mm]}] 
    (home) -| (docs);

  \draw[black, -{Latex[length=2.5mm]}] 
    (home) -| (help);

  \draw[black, -{Latex[length=2.5mm]}] 
    (login) -- (new);

  \draw[black, -{Latex[length=2.5mm]}] 
    (new) -| node[above] {Yes} (acc);

  \draw[black, -{Latex[length=2.5mm]}] 
    (new) -| node[above] {No} (back);

  \draw[black, -{Latex[length=2.5mm]}] 
    (acc) -- (add);

  \draw[black, -{Latex[length=2.5mm]}] 
    ([yshift=0.25cm]add) -| (new);
  
  \draw[black, -{Latex[length=2.5mm]}] 
    (back) -- (main);

  \draw[black, -{Latex[length=2.5mm]}] 
    (back) -- (main);

  \draw[black, -{Latex[length=2.5mm]}] 
    (main) -| (join);

  \draw[black, -{Latex[length=2.5mm]}] 
    (join) -- (code) ;

  \draw[black, -{Latex[length=2.5mm]}] 
    (code) -- (valid) ;
 
  \draw[black, -{Latex[length=2.5mm]}] 
    (valid) -| node[above] {Yes} (codegood) ;

  \draw[black, -{Latex[length=2.5mm]}] 
    (valid) -| node[above] {No} (codebad); 

  \draw[black, -{Latex[length=2.5mm]}] 
    ([xshift=0.4cm]codebad.north) -- (here) -- (code.east); 
  
  \draw[black, -{Latex[length=2.5mm]}] 
    (main) -- (create) ;

  \draw[black, -{Latex[length=2.5mm]}] 
    (create) -- (invite) ;

  \draw[black, -{Latex[length=2.5mm]}] 
    ([yshift=-0.25cm]main) -| (settings);

  \draw[black, -{Latex[length=2.5mm]}] 
    (settings) -- (access);

  \draw[black, -{Latex[length=2.5mm]}] 
    (settings) -| (video);

  \draw[black, -{Latex[length=2.5mm]}] 
    (settings) -| (audio);

  \draw[black, -{Latex[length=2.5mm]}] 
    (video) -- (save);

  \draw[black, -{Latex[length=2.5mm]}] 
    (audio.south) -- (b) -- (save.west);

  \draw[black, -{Latex[length=2.5mm]}] 
    (access.south) -- (a) -- (save.east);

\end{tikzpicture}

\caption{Decomposition of the problem.}
\end{figure}

\subsection*{Explaining and justifying the breakdown}

As discussed in \ref{sec:computational} decomposition can 
reduce the complexity of a system by providing clear sub-tasks
that need to be achieved in order to solve a larger more 
complicated task. Moreover this method of organising tasks 
motivates a more modular approach to the implementation of our
system; each one of the main sub-tasks is neatly and clearly 
visualised and the overall presentation shows how each
sub-task relates to the others. \\ \vspace{0.2cm}

Starting from the top of the diagram I chose to display a
home page once the user initially accesses our website. The 
home page will be primarly used to greet the user, show them 
what the web-app can do and get them to login. However from
the home page users will also be able to access the system 
documentation as well as a help page if users are having issues
with using the system. We justify the need for a homepage by 
highlighting the importance of a first impression. A 
well-designed homepage can capture the attention of the user
and encourage them to explore the rest our web-app. If the
homepage is able to provide a good first impression we will be
able to garner a larger userbase, and simultaneously ensure an 
excellent user experience as they move around the UI. Moreover
if our users are satisfied then our client will be too. 
Documentation for the system will also be freely available to 
find on the the home page to be easily accessible for
developers. Furthermore the inclusion of the documentation 
on the home page means that developers aren't forced to create
an account just to read the documentation, saving much time for
these users. In this manner the system becomes entirely 
\textit{self-contained}, that is no other external resources 
would be necessary in order to use, maintain or update the
system. Finally in the case that users are experiencing issues
with the software a help page will also be clearly available on
the home page in order to answer FAQs as well as guide the user
through any troubleshooting. \\ \vspace{0.2cm}

The next pages require the user to first login. Upon entering 
the login page the user will be asked whether this is their 
first time using our system and if so they will be prompted to 
create an account. If it isn't the user's first time on our 
application then they will enter their username and password
and login to their account. The reason that we ask the user to 
login is because we would like each user to video conference 
with the settings that are most comfortable for them, once the
user logs in we can apply their specific accessibility 
settings that are tied to their account. Therefore in asking
the user to login before they begin video conferencing we are 
encouraging the user to take full advantage of our software by 
allowing them to first, adjust the settings to match their 
needs and requirements. \\ \vspace{0.2cm}

Once the user has logged in they will have complete access to 
the entire functionality of our web-app. I decided to seperate
the main content of the system into 3 pages, 1) Settings page,
2) Create call page, 3) Join call page. I chose to split the 
application into 3 main pages so that users won't have to 
search the app through one long overcrowded page in order to 
find what they are looking for. With this system users will be
able to quickly navigate to the page that they need and find 
what they are looking for easily on that page. Additionally, 
the concept of splitting our content onto multiple pages is 
easily scalable, if the site is updated and more content is 
added the developers can simply add a new page onto the site.
Consequently the system can rapidly expand in order to 
accommodate the growing number of user demands without
requiring a full website re-design each time an update is 
made. \\ \vspace{0.2cm}

The settings page will be where all the configurations and 
options for our system can be set/changed. It will be split
into 3 main tabs; the audio tab, the video tab and the 
accessibility tab. Each tab will hold settings related to it's
name that is, the audio tab will hold settings related volume
and sound and etc. Once a user makes some changes to any of the
settings their changes will be saved to their account and this 
data will remain on the database. The descision to split 
settings into 3 main tabs not only improves the user experience
by allowing users to find the settings they are looking for
easily but it's also in harmony with one of my client's main 
requests for this project; to have a \textit{"focus on 
simplicity"}. The descision to have settings for our system
will help each user to tailor their video conferencing
experience to fit to their personal needs. This allows us to 
create 1 system that is able to accommodate for a large 
number of people enhancing the accessibility of our platform, 
a request outlined by my client in \ref{sec:interview}. 

\newpage
\subsection{Defining the structure of the solution}

\subsubsection{Entity relationship diagram â€” \textit{Draft}}
\label{sec:erdd}

% We need to store user logins, 
% user configurations say video, audio and accessibility 
% so 3 tables, one with logins, one with configurations, 
% etc... 

\textit{The acronym "cfg" denotes configuration.}

\begin{figure}[H]
\centering

\begin{tikzpicture}

  \pic{entity={logins}{\sffamily Logins}{
    \underline{UserID} & \texttt{int} \\
    Username & \texttt{string} \\
    Password & \texttt{string} \\
  }};

  \pic[below right=of logins]{entity={video}{\sffamily Video\_cfg}{
    \textit{UserID} & \texttt{int} \\
    Video quality & \texttt{int} \\
    Video on by default & \texttt{bool} \\
  }};

  \pic[below left=of logins]{entity={audio}{\sffamily Audio\_cfg}{
    \textit{UserID} & \texttt{int} \\
    Speaker volume & \texttt{int} \\
    Mic volume & \texttt{int} \\
    Mic on by default & \texttt{bool} \\
    Hide self-view & \texttt{bool} \\
  }};

  \pic[below=of logins]{entity={access}{\sffamily Accessibility\_cfg}{
    \textit{UserID} & \texttt{int} \\
    Font size & \texttt{int} \\
    Macros & \texttt{string} \\
    Closed captioning & \texttt{bool} \\ 
  }};

  \draw[] (logins) -| (video);
  \draw[] (logins) -| (audio);
  \draw[] (logins) -- (access);

\end{tikzpicture}

\caption{The draft ER diagram.}
\label{fig:erdd}
\end{figure}

% config id so that configs that are the same use same id

\textit{Explaining and justifying the ER diagram draft.}
This entity relationship (ER) diagram was my first attempt at
designing the database for this project. It captures the 
general structure and idea that I had in mind for how the
database of my system should work. Loosely there are 4 main 
categories of data, login data, audio configurations,
video configurations and accessibility configurations, that
would have to be stored in our database. Naturally I decided 
to split these 4 categories into 4 individual tables, such 
that each table should hold 1 category of data. This should 
make life simpler once I begin implementation, for example 
when I have to make a queries about a collection of related
pieces of data I will only need to query the 1 table whose 
label should cover the data I need at that point. I make use 
of a unique numeric ID in order to identify each user and this
is seen as the primary key in the table {\sffamily Logins}.
These IDs are then used to link each user account to their 
relevant configurations via the 3 tables ending in 
{\sffamily \_cfg}. Though this design choice was ok for a 
first draft I soon realised that there were obvious
improvements that could be made. I present some of the flaws
of our current design with an illustration. Suppose that you 
wish to find \emph{all} the configurations that a specific 
user has tied to their account.

\begin{algorithm}
\caption{Pseudo code for finding all configurations tied to a
user.}
\label{alg:long}
\sffamily

\begin{algorithmic}[1]
  \Function{Get\_All\_Configs}{ID}
    \Let{User\_ID}{ID}
    \Let{Configs}{$\{\}$} \Comment{Let Configs be an array.}
    \State{}
    
    \State{Configs.insert( Query\_tbl(Audio\_cfg, User\_ID, Speaker volume) )}
    \State{Configs.insert( Query\_tbl(Audio\_cfg, User\_ID, Mic volume) )}
    \State{Configs.insert( Query\_tbl(Audio\_cfg, User\_ID, Mic on by default) )}
    \State{Configs.insert( Query\_tbl(Audio\_cfg, User\_ID, Hide self-view) )}
    \State{\ldots}
    \State{}

    \State{\textbf{return} Configs}
  \EndFunction
\end{algorithmic}

\end{algorithm}

\mdseries

Algorithm \ref{alg:long} shows a sketch of the algorithm
necessary to solve our problem in pseudo-code. Unfortunately
with our database approach this request is tedious and
inelegant. The function will call the \code{Query\_tbl()}
function 9 times! Not only will this function be slow, due to
the repeated queries to an external database, but it
also violates the DRY software development principle we are
adhering to, as discussed in \ref{sec:computational}. We now 
propose a solution to this issue that allows us to use at most
2 calls to the \code{Query\_tbl()} function.

\subsubsection{Entity relationship diagram â€” \textit{Final}}

\begin{figure}[H]
\centering

\begin{tikzpicture}

  \pic{entity={logins}{\sffamily Logins}{
    \underline{UserID} & \texttt{int} \\
    \textit{ConfigID} & \texttt{int} \\
    Username & \texttt{string} \\
    Password & \texttt{string} \\
  }};

  \pic[below=of logins]{entity={configs}{\sffamily Configs}{
    \underline{ConfigID} & \texttt{int} \\
    \textit{VideoID} & \texttt{int} \\
    \textit{AudioID} & \texttt{int} \\
    \textit{AccessID} & \texttt{int} \\
    Cfg data & \texttt{string (JSON)} \\
  }};

  \pic[below right=of configs]{entity={video}{\sffamily Video\_cfg}{
    \underline{VideoID} & \texttt{int} \\
    Video quality & \texttt{int} \\
    Video on by default & \texttt{bool} \\
    Video data & \texttt{string (JSON)}\\
  }};

  \pic[below left=of configs]{entity={audio}{\sffamily Audio\_cfg}{
    \underline{AudioID} & \texttt{int} \\
    Speaker volume & \texttt{int} \\
    Mic volume & \texttt{int} \\
    Mic on by default & \texttt{bool} \\
    Hide self-view & \texttt{bool} \\
    Audio data & \texttt{string (JSON)}\\
  }};

  \pic[below=of configs]{entity={access}{\sffamily Accessibility\_cfg}{
    \underline{AccessID} & \texttt{int} \\
    Font size & \texttt{int} \\
    Macros & \texttt{string (JSON)} \\
    Closed captioning & \texttt{bool} \\ 
    Access data & \texttt{string (JSON)}\\
  }};

  \coordinate[right=7.5em of configs.east] (v);
  \coordinate[left=7.5em of configs.west] (a);

  \draw[-{crow's foot}] (configs) -- (logins);
  \draw[-{crow's foot}] (audio.north) -| (a) -- (configs.west);
  \draw[-{crow's foot}] (access) -- (configs);
  \draw[-{crow's foot}] (video.north) -| (v) -- (configs.east);

\end{tikzpicture}

\caption{The final ER diagram.}
\label{fig:erdf}
\end{figure}

\textit{Explaining and justifying the final ER diagram.}
As a pre-requisite to the discussion of our final ER diagram, 
we will first explain exactly what a JSON string is and why we
chose to use it here. A JavaScript object notation (JSON) 
string is a string of key value pairs similar to a hashmap or 
a dictionary. As we can see in the name the format of the
string is based on JavaScript's syntax. One advantage of this
format is that we can quickly turn it into a JavaScript object
with JavaScript's built-in \code{JSON.parse()} function. JSON
syntax is straightforward and easy for developers to read and
understand;

\begin{minted}[
  linenos, bgcolor=codebg, frame=lines, framesep=15\fboxrule,
  framerule=1pt, rulecolor=\color{gray!40}]{js}
  // 32 is the key code for space, 13 is the key code for enter.
  var Access_data = JSON.parse('{
    "Font size": 18,
    "Macros": {
      "Unmute": 32,
      "Cam off": 13 
    },
    "Closed captioning": false
  }');
\end{minted}

the example above presents how the JSON string in the Access 
data attribute may look. Thanks to the JSON syntax our data 
is clear and easily understood, this enables developers to be
able to look at the data that is being stored in these 
JavaScript objects, so that they can have an easier time 
debugging any unintentional results or errors that may occur 
in our database system. Hence the application of JSON strings 
provides a neat and structured format to store data as well as
improves the maintainability of the database portion of our
system. Moreover the format works very nicely in harmony with
the JavaScript programming language, a language that we will
make use of extensively seeing as our system is a web-app, 
because of the close relationship between JavaScript and JSON
syntax. \\ \vspace{0.2cm}

The changes in the final ER diagram all revolve around the new
ConfigID attribute. The user's complete configuration used to 
be comprised of numerous attributes that were stored across
multiple tables. Now each collection of configuration
attributes has been given it's own table in the
{\sffamily Configs} table. This table stores a string, more 
precisely a JSON string, that maps each configuration
attribute to it's corresponding value. In essence instead of 
treating each configuration attribute as it's own seperate
object, we now store all of a user's configurations together
in one object, like how a bag stores a collection of items. 
This approach to our database design allows us to solve the 
problem we had in \ref{fig:erdd}, now in order to request 
\textit{all} of a user's configurations we may use the 
following two-liner;\\

\begin{center}
\begin{tblr}{colspec={l}, rowsep=0pt}
  {\sffamily Config\_ID} $\gets$ {\sffamily Query\_tbl(Logins, UserID, ConfigID)}\\
  {\sffamily \textbf{return} Query\_tbl(Configs, Config\_ID, Cfg data)}\\
\end{tblr}
\end{center}

Not only is this code much shorter and more clear than the 
code in algorithm \ref{alg:long} but it will also run much
faster, with just 2 calls to \code{Query\_tbl()}. Moreover
with this new approach we can still adhere to the DRY software
development principle, since we are no longer forced to repeat
code unnecessarily. The database is also in 3rd normal form
enhancing the efficiency of our system as 
well as ensuring that data integrity is achieved.
Another issue that this new design solves
is duplicate configurations. For instance in figure 
\ref{fig:erdd} if 2 users happen to have the same
configuration then this data will simply be duplicated in our 
table and take up unnecessary space in our table. However 
with the design in figure \ref{fig:erdf} if 2 users have for
example the same audio settings then they can simply use the
same audio ID, meaning that this specific audio configuration 
only needs to be stored once in our database. It is clear to 
see that with this new approach we not only save memory in 
the long term, at the cost of 1 extra table, but we also 
improve the performance of our system dramatically. \\
\vspace{0.2cm}

Although the
database system will increase in size temporarily I argue that
the size of the database will be smaller as compared to the 
draft database design as the number of users increases. All of
our configuration options take a discrete set of values, for 
instance font size will only be able to take on an integer
value $12 \leq f \leq 40$. For each configuration option let
$c_1, c_2, \ldots, c_N$ be the of length $N$ sequence of all
the possible configurations for our 
system (note that this is allowed because all of configuration
options are numerical, the \texttt{bool} data type can simply
be represented by a number that is either 0 or 1). Denote
$c_i$ to be the $i$-th configuration and $|c_i| \in \mathbb{N}$
to be the number of possible options that this configuration 
can take on. Suppose that we have $n$ users in our system,
for each configuration option let
$X_{i, 1}, X_{i, 2}, \ldots, X_{i, n}$ a sequence of $n$
independent discrete uniform random variables, 
where $X_{i, j}$ denotes the value of the $i$-th configuration
option for the $j$-th user. Let $\mu_i$ be the finite expected
value of the $i$-th configuration. Denote $\overline{X_i}$ to 
be the sample mean of the $i$-th configuration for all or our
$n$ users. By \textit{Kolmogorov's strong law} \cite{thm}
we have,

\begin{equation} \label{eq:kol}
  Pr \left(\lim_{n \to \infty} \overline{X_i} = \mu_i \right) = 1
\end{equation}

over all valid values of $i$. From the definition of a limit
we can conclude that as $n$ grows larger the sample mean 
converges almost surely to it's expected value. Whilst
equation \ref{eq:kol} can provide some motivation for the 
direction of our arguement \textit{Kolmogorov's strong law}
cannot be applied because we can never have an infinite number
of users in our system. Instead we will consider the
configuration option $c_m$ where this configuration option is
able to take on the largest number of values. Formally, we
take a configuration option $c_m$ such that
$\max_{i=1}^{N} |c_i| = m$. We will then show that with a 
sufficiently large userbase that users will inevitably start
picking the same values for their configuration options. The 
options that are able to take on the largest number of values 
are the 2 volume options in {\sffamily Audio\_cfg}. We let 
users choose some integer volume $0 \leq v \leq 100$. By the 
\textit{pigeonhole principle} once we have 102 users we 
must have at least 2 users who have chosen the same 
volume $v$. This is because we have 101 different options for 
the value that $v$ could take on, and in the worst case 
scenario each user would take on a unique value of $v$. Above
the threshold of 101 users every value of $v$ would already 
have at least 1 user who has selected this value and hence the
$102^{nd}$ user has to choose a volume value which someone else
has already chosen. More generally starting from user 1, every
$101^{th}$ user must choose a volume that has already been 
chosen before causing a new duplicate. This is seen by 
repeatedly applying the \textit{pigeonhole principle}. As the
number of users increase the number of duplicates for volume
grows linearly. For instance if we have just 
$1011 = 101 \cdot 10 + 1$ users then we must
have at least 10 duplicates for values of $v$. More worryingly
since the volume example was the worst case scenario (because
volume has the largest number of options that a user can 
choose) we can see that every other configuration option will 
also have to have $\geq 10$ duplicates. We have 9 options 
total so across all tables there has to be at least 90
duplicates, and in fact the number of duplicates will be much 
greater in reality. The 4 boolean options will have
duplicates every 2 users! Hence these options will at least
505 duplicates (from the calculation $2 \cdot 505 + 1 = 1011$).
Multiplying by the 4 boolean options yields 2020 duplicates
\textit{minimum} over the 4 boolean options only! It is not 
hard to see that once the number of users starts to grow our
database will rapidly fill up with duplicates resulting in
catastrophically large database sizes and hence users will be
unable to use our system as their data simply can no longer  
recorded in our database. With our final database design we 
can guarantee that our database won't have any duplicates 
saving me and my client from a multitude of economical and 
logistical issues in the future. \\ \vspace{0.2cm}
%mumble mumble Central limit thm, lots of collisions mumble 

\subsubsection{Proposed system level 0 DFD}

\begin{figure}[H]
\label{fig:dfd0}
\centering
\begin{tikzpicture}

  \node[draw, rectangle, minimum width=4cm, minimum height=1cm,
	fill=lightestgray]
    (sys) {\large Proposed system};

  \node[draw, ellipse, minimum width=3cm, minimum height=1.5cm,
	below right=of sys]
    (user) {\large Users};

  \node[draw, ellipse, minimum width=3cm, minimum height=1.5cm,
	below left=of sys]
    (host) {\large Host};

  \node[draw, ellipse, minimum width=3cm, minimum height=1.5cm,
	above=of sys]
    (main) {\large Maintainers};

  \draw[black,  -{Latex[length=2.5mm]}]
	  (sys) edge["1"] (main);
  \draw[black, bend left=0.5cm, -{Latex[length=2.5mm]}]
	  (host) edge["2"] (sys);
  \draw[black, bend left=0.5cm, -{Latex[length=2.5mm]}]
	  (sys) edge["3"] (host);
  \draw[black, bend left=0.5cm, -{Latex[length=2.5mm]}]
	  (sys) edge["3"] (user);
  \draw[black, bend left=0.5cm, -{Latex[length=2.5mm]}]
	  (user) edge["4"] (sys);
  \draw[black, bend right=0.5cm, -{Latex[length=2.5mm]}]
	  (host) edge["5"] (user);
  \draw[black, bend left=0.5cm, -{Latex[length=2.5mm]}]
          (user) edge (host);

\end{tikzpicture}

\caption{Proposed system level 0 DFD diagram.}
\end{figure}

\textit{An explanation of the DFD is found below. The number 
closest to each edge refers to the number in the left column
of the explanation table below.} \vspace{-0.2cm}

%recieve feedback from users
\begin{longtblr}[
  caption={Explanation of proposed system DFD.}
]{
  colspec={lX}, hlines, row{1}={lightestgray}
}

Edge & Commentary \\

1 & {Maintainers recieve and analyse information relating to 
     the performance of the proposed system, and use the
     documentation provided with the system to suggest and 
     make any necessary changes.} \\

2 & {The host uses the proposed system in order to commence
     video conferences and to invite all those whom they would
     like to. Moreover the host will use the system to admit 
     or remove people from the video conference, as they 
     wish.} \\

3 & {The system provides the host with live audio and video 
     from all the other participants in the video conference,
     provided their microphone or camera are connected and that
     the user has activated their microphone or camera from
     their end.}\\

4 & {The user connects to video conferences via a code that 
     was given to them by the host of the meeting. They can 
     also raise their hand and tailor their experience via
     the settings page.}\\

5 & {Hosts and users are both able to communicate either via 
     their microphones or via the built-in chat box on every 
     video conference.}\\
  
\end{longtblr}

\textit{Justifying the DFD.} The DFD above allows me and my 
client to be able to clearly understand the plans for the 
proposed system, in terms of some of it's main features and 
functionalities. Furthermore the DFD diagram can be compared to
the previous system's DFD diagram to ensure that the new 
system is an adequate replacement, as discussed in
\ref{sec:currdfd}. The usage of primitive shapes and clear 
labelling ensures that the diagram is easily digestible, such 
that even those who don't understand anything about software
architecture will be able to grasp the structure of the 
proposed solution. Consequently these diagrams also work to 
improve the maintainability of the system, even new developers
with minimal programming experience will have an intuitive 
understanding of how the proposed system works and it's
overarching structure. Hence thanks to the creation of these 
diagrams we do not only equip the future maintainers of this 
system with all the necessary understanding that they require
to make changes, but we also promote a design culture of clear
and maintable software. Then if the future maintainers of this
software feel motivated to do the same we can ensure that our 
software will maximise it's longevity, through the constant 
innovation and improvement of our system namely via it's 
future maintainers.

\subsubsection{Proposed system level 1 DFD}

\subsection{\textsf Proposed algorithms}
